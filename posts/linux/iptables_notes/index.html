<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="iptables 介绍 原理解析 1. 接收数据包 2. iptables 原理 总结 iptables 介绍 iptables 是一个用户空间实用程序，允许系统管理员配置 Linux 内核防火墙功能，如 IP 包过滤规则等，底层是基于 netfilter 内核模块实现 1。 通过 iptables 可以对 Linux 系统的网络数据包执行检测、修改、转发、重定向和丢弃等操作, 应用层可以便捷高效地实现 帧过滤、网络审计、连接追踪、帧修改、NAT、Masquerading、端口转发和负载均衡等强大功能2。很多知名项目都借助 iptables 实现完善功能，比如 ufw3, docker4, HAProxy5, LVS6 等。
以下为一些常用的 iptables 命令7：
# 通过 iptables-persistent 持久化保存 rules # > sudo apt install iptables-persistent # To accept all traffic on your loopback interface sudo iptables -A INPUT -i lo -j ACCEPT sudo iptables -A OUTPUT -o lo -j ACCEPT # allow outgoing traffic of all established connections sudo iptables -A OUTPUT -m conntrack --ctstate ESTABLISHED -j ACCEPT # allows established and related incoming traffic, allow return traffic for outgoing connections initiated by the server itself."><title>iptables 笔记</title><link rel="shortcut icon" type=image/x-icon href=/><link rel=stylesheet href=/css/main.ebe15b0394daa6798b8a40aa572a71b5a7a1beb8cc02c392f5c142e7d08ddb6052e049639385106440b538f394884685082b7441eef27a6a8315ec723155dc15.css integrity="sha512-6+FbA5TapnmLikCqVypxtaehvrjMAsOS9cFC59CN22BS4Eljk4UQZEC1OPOUiEaFCCt0Qe7yemqDFexyMVXcFQ=="></head><body a=auto><main class=page-content aria-label=Content><div class=w><a href=/>..</a><article><p class=post-meta><time datetime="2023-05-28 15:20:20 +0800 +0800">2023-05-28</time></p><h1>iptables 笔记</h1><ul><li><a href=#iptables-%E4%BB%8B%E7%BB%8D><code>iptables</code> 介绍</a></li><li><a href=#%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90>原理解析</a><ul><li><a href=#1-%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E5%8C%85>1. 接收数据包</a></li><li><a href=#2-iptables-%E5%8E%9F%E7%90%86>2. <code>iptables</code> 原理</a></li></ul></li><li><a href=#%E6%80%BB%E7%BB%93>总结</a></li></ul><hr><h1 id=iptables-介绍><code>iptables</code> 介绍</h1><p><code>iptables</code> 是一个用户空间实用程序，允许系统管理员配置 Linux 内核防火墙功能，如 IP 包过滤规则等，底层是基于 <code>netfilter</code> 内核模块实现 <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>。 通过 <code>iptables</code> 可以对 Linux 系统的网络数据包执行检测、修改、转发、重定向和丢弃等操作, 应用层可以便捷高效地实现 帧过滤、网络审计、连接追踪、帧修改、NAT、Masquerading、端口转发和负载均衡等强大功能<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>。很多知名项目都借助 <code>iptables</code> 实现完善功能，比如 <code>ufw</code><sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>, <code>docker</code><sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>, <code>HAProxy</code><sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>, <code>LVS</code><sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup> 等。</p><p>以下为一些常用的 <code>iptables</code> 命令<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 通过 iptables-persistent 持久化保存 rules</span>
</span></span><span style=display:flex><span><span style=color:#75715e># &gt; sudo apt install iptables-persistent</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># To accept all traffic on your loopback interface</span>
</span></span><span style=display:flex><span>sudo iptables -A INPUT -i lo -j ACCEPT
</span></span><span style=display:flex><span>sudo iptables -A OUTPUT -o lo -j ACCEPT
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># allow outgoing traffic of all established connections</span>
</span></span><span style=display:flex><span>sudo iptables -A OUTPUT -m conntrack --ctstate ESTABLISHED -j ACCEPT
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># allows established and related incoming traffic, allow return traffic for outgoing connections initiated by the server itself.</span>
</span></span><span style=display:flex><span>sudo iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># allow your internal to access the external (eth0 is your external network, and eth1 is your internal network)</span>
</span></span><span style=display:flex><span>sudo iptables -A FORWARD -i eth1 -o eth0 -j ACCEPT
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># block connections originated from a specific IP address</span>
</span></span><span style=display:flex><span>sudo iptables -A INPUT -s 203.0.113.xx -j DROP
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># reject the connection from the IP address, with a “connection refused” error</span>
</span></span><span style=display:flex><span>sudo iptables -A INPUT -s 203.0.113.xx -j REJECT
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># allow all incoming SSH connections</span>
</span></span><span style=display:flex><span>sudo iptables -A INPUT -p tcp --dport <span style=color:#ae81ff>22</span> -m conntrack --ctstate NEW,ESTABLISHED -j ACCEPT
</span></span><span style=display:flex><span>sudo iptables -A OUTPUT -p tcp --sport <span style=color:#ae81ff>22</span> -m conntrack --ctstate ESTABLISHED -j ACCEPT
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># allow outgoing SSH connections</span>
</span></span><span style=display:flex><span>sudo iptables -A OUTPUT -p tcp --dport <span style=color:#ae81ff>22</span> -m conntrack --ctstate NEW,ESTABLISHED -j ACCEPT
</span></span><span style=display:flex><span>sudo iptables -A INPUT -p tcp --sport <span style=color:#ae81ff>22</span> -m conntrack --ctstate ESTABLISHED -j ACCEPT
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># allow all incoming HTTP and HTTPS connections</span>
</span></span><span style=display:flex><span>sudo iptables -A INPUT -p tcp -m multiport --dports 80,443 -m conntrack --ctstate NEW,ESTABLISHED -j ACCEPT
</span></span><span style=display:flex><span>sudo iptables -A OUTPUT -p tcp -m multiport --dports 80,443 -m conntrack --ctstate ESTABLISHED -j ACCEPT
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># allow incoming MySQL connections from a specific IP address or subnet</span>
</span></span><span style=display:flex><span>sudo iptables -A INPUT -p tcp -s 203.0.113.0/24 --dport <span style=color:#ae81ff>3306</span> -m conntrack --ctstate NEW,ESTABLISHED -j ACCEPT
</span></span><span style=display:flex><span>sudo iptables -A OUTPUT -p tcp --sport <span style=color:#ae81ff>3306</span> -m conntrack --ctstate ESTABLISHED -j ACCEPT
</span></span></code></pre></div><hr><h1 id=原理解析>原理解析</h1><p>那么 <code>iptables</code> 是如何实现这些功能的呢？</p><h2 id=1-接收数据包>1. 接收数据包</h2><p>当网卡接收到与本地 MAC 地址匹配的以太网帧或者是链路层广播，网卡设备会触发中断信号<sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup>。</p><p>然后由网络驱动程序处理中断，并通过 <code>DMA</code> / <code>PIO</code> / 将数据包数据 (从 <code>RX Ring</code>) 读到内存中。在经过对数据包校验后，将数据帧内容存放到 skb(socket buffer) 待进一步处理。</p><p><code>skb</code> 将被排入处理器中断队列中（并激活软中断，延迟执行<sup id=fnref:9><a href=#fn:9 class=footnote-ref role=doc-noteref>9</a></sup>）。如果队列积压已满，则在此处丢弃数据包。中断程序退出。此后 <code>do_softirq()</code> 将被调用，从队列中读出 <code>skb</code> 并将其传递给对应协议的处理函数 (IPv4 的情况下就是 IPv4 数据包处理程序了)。</p><p>在 IPv4 数据包处理程序中，首先进行一些检查和校验（如：IP校验和，长度和版本号等），然后将数据包传递给 <code>netfilter</code> 框架。</p><h2 id=2-iptables-原理>2. <code>iptables</code> 原理</h2><p><code>netfilter</code> 是一个 Linux 内核模块，它提供一个框架用于在数据包通过网络协议栈时执行操作。<code>netfilter</code> 通过 <code>netlink</code> 与用户空间通信，用户空间程序可以通过 <code>netlink</code> 接口向内核注册回调函数，当数据包通过网络协议栈时，内核会调用这些回调函数，从而实现对数据包的处理。</p><p><code>netfilter</code> 提供五个 Hook 点分别是<sup id=fnref:10><a href=#fn:10 class=footnote-ref role=doc-noteref>10</a></sup>：</p><blockquote><p><strong>NF_IP_PRE_ROUTING</strong>: This hook will be triggered by any incoming traffic very soon after entering the network stack. This hook is processed before any routing decisions have been made regarding where to send the packet.</p><p><strong>NF_IP_LOCAL_IN</strong>: This hook is triggered after an incoming packet has been routed if the packet is destined for the local system.</p><p><strong>NF_IP_FORWARD</strong>: This hook is triggered after an incoming packet has been routed if the packet is to be forwarded to another host.</p><p><strong>NF_IP_LOCAL_OUT</strong>: This hook is triggered by any locally created outbound traffic as soon as it hits the network stack.</p><p><strong>NF_IP_POST_ROUTING</strong>: This hook is triggered by any outgoing or forwarded traffic after routing has taken place and just before being sent out on the wire.</p></blockquote><p>用户可以通过 <code>iptables</code> 命令向这些链中添加规则，当数据包通过网络协议栈时，内核会按照优先级依次根据这些规则来处理数据包。
<code>iptables</code>按照表来组织规则 ，常用的表为：<code>filter</code>, <code>NAT</code>(<code>SNAT</code> 和 <code>DNAT</code>), <code>mangle</code>, <code>raw</code> ； 每个表可包含多个规则链。
当一个数据包触发 Hook 点位时，内核会按照优先级依次执行规则链中的规则，直到遇到 <code>ACCEPT</code> 或 <code>DROP</code> 规则，或者规则链中的规则全部执行完毕。</p><p>详细的流转表<sup id=fnref:11><a href=#fn:11 class=footnote-ref role=doc-noteref>11</a></sup>：</p><p><img src=https://www.frozentux.net/iptables-tutorial/images/tables_traverse.jpg alt=tables_traverse></p><h1 id=总结>总结</h1><p>本文介绍了 <code>iptables</code> 的基本使用方法，以及基于 <code>netfilter</code> 内核模块的实现原理。整体上对 <code>iptables</code> 有了一般性的了解。
更深入的学习可以参考各种资料和开源项目，甚至可以自己动手实践。</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>iptables Wiki: <a href=https://en.wikipedia.org/wiki/Iptables>https://en.wikipedia.org/wiki/Iptables</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>iptables Arch Wiki: <a href=https://wiki.archlinuxcn.org/wiki/Iptables>https://wiki.archlinuxcn.org/wiki/Iptables</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>ufw tutorials: <a href=https://www.digitalocean.com/community/tutorials/how-to-set-up-a-firewall-with-ufw-on-ubuntu-22-04>https://www.digitalocean.com/community/tutorials/how-to-set-up-a-firewall-with-ufw-on-ubuntu-22-04</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>docker(moby): <a href=https://github.com/moby/moby/blob/e1c92184f08153456ecbf5e302a851afd6f28e1c/libnetwork/iptables/iptables.go#L4>https://github.com/moby/moby/blob/e1c92184f08153456ecbf5e302a851afd6f28e1c/libnetwork/iptables/iptables.go#L4</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>HAProxy: <a href=https://github.com/haproxy/haproxy/blob/b7f8af3ca9424984e557f2c95c639dd4f57dfe61/doc/architecture.txt#L768>https://github.com/haproxy/haproxy/blob/b7f8af3ca9424984e557f2c95c639dd4f57dfe61/doc/architecture.txt#L768</a>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p>LVS tutorials: <a href=https://www.cnblogs.com/jmilkfan-fanguiju/p/10589739.html>https://www.cnblogs.com/jmilkfan-fanguiju/p/10589739.html</a>&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p>iptables tutorails: <a href=https://www.digitalocean.com/community/tutorials/iptables-essentials-common-firewall-rules-and-commands>https://www.digitalocean.com/community/tutorials/iptables-essentials-common-firewall-rules-and-commands</a>&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:8><p>The journey of a packet through the linux 2.4 network stack: <a href=http://ftp.gnumonks.org/pub/doc/packet-journey-2.4.html>http://ftp.gnumonks.org/pub/doc/packet-journey-2.4.html</a>&#160;<a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:9><p>interrupts > Soft IRQs: <a href=https://linux-kernel-labs.github.io/refs/heads/master/lectures/interrupts.html#soft-irqs>https://linux-kernel-labs.github.io/refs/heads/master/lectures/interrupts.html#soft-irqs</a>&#160;<a href=#fnref:9 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:10><p>iptables&amp;netfilter arch: <a href=https://www.digitalocean.com/community/tutorials/a-deep-dive-into-iptables-and-netfilter-architecture>https://www.digitalocean.com/community/tutorials/a-deep-dive-into-iptables-and-netfilter-architecture</a>&#160;<a href=#fnref:10 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:11><p>tables_traverse: <a href=https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html#TRAVERSINGOFTABLES>https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html#TRAVERSINGOFTABLES</a>&#160;<a href=#fnref:11 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article></div></main></body></html>